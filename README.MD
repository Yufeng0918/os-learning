# 操作系统

## 1. 综述

### 1.1 系统组成

![](./images/os-06.png)



### 1.2 命令行

#### 文件目录

```SHELL
# ls -l
drwxr-xr-x 6 root root    4096 Oct 20  2017 apt
-rw-r--r-- 1 root root     211 Oct 20  2017 hosts
```

第一个字段的第一个字符是文件类型。如果是“-”，表示普通文件；如果是 d，就表示目录。第一个字段剩下的 9 个字符是权限位（access permission bits）。3 个一组，**每一组 rwx 表示“读（read）”“写（write）”“执行（execute）”**。

第二个字段是硬链接（hard link）数目

#### 服务运行

Ubuntu 中，通过 apt-get install mysql-server 的方式安装 MySQL，**在 /lib/systemd/system 目录下会创建一个 [*].service 的配置文件**

CentOS 中，在 **/usr/lib/systemd/system** 目录下，创建一个 [*].service 的配置文件

+ 通过命令systemctl start mysql启动 MySQL
+ 通过systemctl enable mysql设置开机启动。

![](./images/os-07.png)



### 1.3 系统调用

#### 进程管理

创建一个新的进程，需要一个老的进程调用 fork 来实现，老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。对于 fork 系统调用的返回值

+ 如果当前进程是子进程，就返回 0
+ 如果当前进程是父进程，就返回子进程的进程号

子进程，需要请求另一个系统调用**execve**来执行另一个程序

系统调用waitpid，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程是否运行完成和成功。



#### 内存管理

代码段是放程序代码的这部分。数据段是放进程运行中产生数据的。

当分配的内存数量比较小的时候，**使用 brk，会和原来的堆的数据连在一起。**

当分配的内存数量比较大的时候，**使用 mmap，会重新划分一块区域。**



#### 文件管理

文件的操作

+ 打开文件使用open，close关闭这个文件
+ 创建没有的文件可以使用create
+ 打开文件以后，可以使用lseek跳到文件的某个位置
+ 对文件的内容进行读写，读的系统调用是read，写是write

**Linux 里有一个特点，那就是一切皆文件**

+ 启动一个进程，需要一个程序文件，这是一个**二进制文件**
+ 加载一些配置文件，打印一些日志，这是**文本文件**
+ 日志打印到交互控制台上，是**标准输出 stdout 文件**
+ 这个进程的输出可以作为另一个进程的输入，这种方式称为管道，**管道**也是一个文件。
+ 进程可以通过网络和其他进程进行通信，**建立的 Socket，也是一个文件。**
+ 进程需要访问外部设备，**设备也是一个文件。**
+ 文件都被存储在文件夹里面，其实**文件夹也是一个文件。**
+ 进程运行起来，要想看到进程运行的情况，**会在 /proc 下面有对应的进程号，还是一系列文件。**

**Linux 都会分配一个文件描述符（File Descriptor）**，这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。



#### 信号处理

SIGKILL：用于终止一个进程的信号

SIGSTOP：用于中止一个进程的信号



#### 中介Glibc

Glibc 为程序员提供丰富的 API，最重要的是**封装了操作系统提供的系统服务，即系统调用的封装。**

![](./images/os-08.png)



## 2. 系统初始化

### 2.1 x86架构

核心是CPU，**CPU和其他设备通过总线连接**

![](./images/os-09.png)

#### CPU 架构

![](./images/os-10.png)

CPU包括三个部分，运算单元、数据单元和控制单元。

+ 运算单元只管算，例如做加法、做位移等等。
+ 数据单元根据数据的地址，从数据段里读到数据寄存器里。
+ 控制单元获得下一条指令，然后执行这条指令。这个指令会指导**运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。**
  + **指令指针寄存器**存放的是下一条指令在内存中的地址
  + **指令寄存器**拿进来的代码段的指令

总线分为两类

+ 地址总线：内存中哪个位置的数据
+ 数据总线：传输数据

x86实现了开放、统一、兼容规范



#### 8086 CPU

数据单元：8 个 16 位的通用寄存器。e.g. AX、BX、CX、DX、SP、BP、SI、DI

控制单元

+ IP 寄存器： 指令指针寄存器
+ CS 代码段寄存器（Code Segment Register）可以找到代码在内存中的位置
+ DS 数据段的寄存器（Data Segment Register），可以找到数据在内存中的位置
+ SS 栈寄存器（Stack Register）, 函数调用

IP寄存器和通用寄存器都是 16 位的。CS 和 DS 都是 16 位的，但是总线是20位，所以CS 和 DS 中的值**左移 4 位，**变成 20 位的，**加上 16 位的偏移量得到最终 20 位的数据地址**



#### 32位 CPU

通用寄存器: 扩展到 8 个 32 位的

CS/DS/SS/ES: 段的起始地址放在内存的某个地方。如同表格，表格中的一项一项是段描述符（Segment Descriptor）。**段描述符才是真正的段的起始地址。**段寄存器里面保存的是选择子（Selector），是指向这个表格中的某一项。

+ 实模式：段寄存器指向内存地址

+ 保护模式：段寄存器指向表格中的段描述符

CPU在启动时逐渐从实模式切换到保护模式。



### 2.2 内核加载

![](./images/os-11.png)

#### BIOS

ROM（Read Only Memory，只读存储器）保存BIOS（Basic Input and Output System，基本输入输出系统）。x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM， BIOS开始初始化工作。

+ 检查系统的硬件
+ 建立一个中断向量表和中断服务程序，e.g. 鼠标和键盘操作都是通过中断



#### bootloader

Linux 里面有Grub2，全称 Grand Unified Bootloader Version 2，用于系统启动的。

+ boot.img 从硬盘加载到内存中的 0x7c00 来运行
+ grub2安装boot.img，由 boot.S 编译而成，一共 512 字节，正式安装到启动盘的第一个扇区。通常称为 MBR（Master Boot Record，主引导记录 / 扇区）。
+ boot.img 先加载的是 core.img 的第一个扇区， boot.img 将控制权交给 diskboot.img
+ diskboot.img将 core.img 的其他部分加载进来



#### 保护模式

+ 打开 Gate A20，第 21 根地址线的控制线。
+ **启用分段**，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了
+ **启动分页**，能够管理的内存变大了，就需要将内存分成相等大小的块
+ 解压lzma_decompress.img
+ 解压kernel.img，运行grub2 keneral
+ **Grub2 启动 linux内核**



### 2.3 内核初始化

![](./images/os-12.png)

#### 初始化管理子系统

+ 创建的0 号进程
+ 初始化系统调用模块，包括中断们用于输入输出
+ 初始化内存管理模块
+ 初始化基于内存的文件系统，文件系统为了兼容各种各样的文件系统，需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 VFS（Virtual File System），虚拟文件系统。



#### 初始化1号/2号进程

rest_init 的第一工作是用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建1号进程管理用户进程

rest_init 的第一工作是用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建2号进程管理内核进程



#### 内核态/用户态切换

![](./images/os-13.png)

内核态（Kernel Mode）：能够访问关键资源的代码放在 Ring0

用户态（User Mode）: 普通的程序代码放在 Ring3

![](./images/os-14.png)

### 2.4 系统调用

#### 32位系统调用

+ 将请求参数放在寄存器里面
+ 根据系统调用名称，得到系统调用号，放在寄存器 eax 里面
+ 执行 ENTER_KERNEL
+ 从 eax 里面取出来系统调用号，然后根据系统调用号，在系统调用表sys_call_table中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数
+ iret 指令将原来用户态保存的现场恢复回来

![](./images/os-15.png)

#### 64位系统调用

+ 将请求参数放在寄存器里面
+ 根据系统调用名称，得到系统调用号，放在寄存器 eax 里面
+ 执行 syscall 进入内核， syscall是特殊模块寄存器，为CPU执行系统调用
+ 从rax 里面拿出系统调用号，然后根据系统调用号，在系统调用表 sys_call_table 中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数
+ sysretq 指令将原来用户态保存的现场恢复回来

![](./images/os-16.png)

#### 系统调用表

32 位的系统调用表定义在 arch/x86/entry/syscalls/syscall_32.tbl 文件里

64 位的系统调用定义在另一个文件 arch/x86/entry/syscalls/syscall_64.tbl 里

+ 第一列的数字是系统调用号
+ 第三列是系统调用的名字
+ 第四列是系统调用在内核的实现函数。

```assembly
2  common  open      sys_open
```



## 3. 进程管理